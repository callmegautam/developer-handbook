### Global, Local, and Block Scope

**Scope** defines the region of code where a variable can be accessed.

- **Global Scope:** Declared outside any function or block; accessible anywhere.
    
    ```js
    var x = 10;
    function show() {
      console.log(x); // 10
    }
    ```
    
- **Local (Function) Scope:** Declared inside a function; accessible only within it.
    
    ```js
    function demo() {
      let y = 20;
      console.log(y);
    }
    console.log(y); // Error
    ```
    
- **Block Scope:** Variables declared with `let` or `const` inside `{}` exist only within that block.
    
    ```js
    {
      let z = 30;
    }
    console.log(z); // ReferenceError
    ```
    

`var` is not block-scoped — it leaks out of blocks but stays within functions.

---

### Lexical Environment

A **lexical environment** is the internal structure that holds variable bindings and references created during code execution.

It has:

1. **Environment Record:** Stores variable and function declarations.
    
2. **Reference to Outer Lexical Environment:** Links to the parent scope.
    

Each function creates a new lexical environment upon execution, capturing variables from where it was **defined**, not where it’s **called**.

```js
function outer() {
  let a = 10;
  function inner() {
    console.log(a); // 10 (captured from outer)
  }
  inner();
}
outer();
```

This lexical scoping enables **closures**.

---

### Scope Chain Resolution

When JavaScript tries to access a variable:

1. It looks in the **current scope**.
    
2. If not found, it moves up the **outer scopes** via the lexical environment links.
    
3. If still not found, it checks the **global scope**.
    
4. If absent there too → `ReferenceError`.
    

```js
let x = 1;
function outer() {
  let y = 2;
  function inner() {
    let z = 3;
    console.log(x, y, z); // 1 2 3
  }
  inner();
}
outer();
```

If multiple scopes have the same variable name, **nearest scope wins** (variable shadowing).

---

### Hoisting (Variables + Functions)

During the **creation phase**, JS moves declarations to the top of their scope before execution.

**Functions:** Fully hoisted — you can call them before declaration.

```js
sayHello(); // works
function sayHello() { console.log("Hi"); }
```

**Variables:**

- `var` → hoisted but initialized to `undefined`.
    
- `let` and `const` → hoisted but **not initialized** (in TDZ).
    

```js
console.log(a); // undefined
var a = 5;

console.log(b); // ReferenceError (TDZ)
let b = 10;
```

---

### Temporal Dead Zone (TDZ)

The TDZ is the period between entering a scope and variable initialization (for `let`/`const`).

Accessing the variable during TDZ throws an error.

```js
{
  console.log(x); // ReferenceError
  let x = 5;
}
```

This behavior ensures that variables cannot be used before their declaration, preventing accidental bugs from hoisting.