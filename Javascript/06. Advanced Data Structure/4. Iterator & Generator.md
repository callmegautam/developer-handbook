## 4. Iterators & Generators

### Iterable Protocol

An **iterable** is any object that implements the method `Symbol.iterator`, which returns an **iterator** â€” an object that defines how to produce a sequence of values.

```js
const arr = [10, 20, 30];
const iterator = arr[Symbol.iterator]();

console.log(iterator.next()); // { value: 10, done: false }
console.log(iterator.next()); // { value: 20, done: false }
console.log(iterator.next()); // { value: 30, done: false }
console.log(iterator.next()); // { value: undefined, done: true }
```

**Built-in iterables:**  
Arrays, Strings, Maps, Sets, and arguments objects.

Iterables can be consumed using:

- `for...of`
    
- Spread syntax (`[...iterable]`)
    
- Destructuring (`const [a, b] = iterable`)
    
- `Array.from(iterable)`
    

---

### Custom Iterators

You can define your own iterator by implementing the `Symbol.iterator` method.

```js
const range = {
  start: 1,
  end: 3,
  [Symbol.iterator]() {
    let current = this.start;
    const end = this.end;
    return {
      next() {
        if (current <= end) {
          return { value: current++, done: false };
        }
        return { done: true };
      }
    };
  }
};

for (const num of range) {
  console.log(num); // 1, 2, 3
}
```

Each call to `next()` returns an object `{ value, done }`.

---

### Generator Functions (`function*`)

A **generator** is a special function that can pause and resume its execution using the `yield` keyword.  
Defined with an asterisk (`function*`).

```js
function* gen() {
  yield 1;
  yield 2;
  yield 3;
}

const it = gen();
console.log(it.next()); // { value: 1, done: false }
console.log(it.next()); // { value: 2, done: false }
console.log(it.next()); // { value: 3, done: false }
console.log(it.next()); // { value: undefined, done: true }
```

Generators automatically implement the iterable protocol, so you can use them in `for...of` loops:

```js
for (const val of gen()) console.log(val);
```

---

### Yield and Generator Composition

`yield` pauses execution, and `return` ends the generator.

```js
function* count() {
  yield 1;
  yield 2;
  return 3;
}

for (const val of count()) console.log(val); // 1, 2
```

**Yield expressions** can also receive input:

```js
function* dialogue() {
  const name = yield "What's your name?";
  yield `Hello, ${name}!`;
}

const d = dialogue();
console.log(d.next().value); // "What's your name?"
console.log(d.next("Gautam").value); // "Hello, Gautam!"
```

**Generator composition** allows combining multiple generators:

```js
function* genA() { yield 1; yield 2; }
function* genB() { yield* genA(); yield 3; }

for (const val of genB()) console.log(val); // 1, 2, 3
```

`yield*` delegates iteration to another generator or iterable.

---

### Async Iterators (`for await...of`)

For asynchronous sequences, JS provides **async iterators** that return Promises.

```js
async function* asyncCounter() {
  for (let i = 1; i <= 3; i++) {
    await new Promise(r => setTimeout(r, 500));
    yield i;
  }
}

(async () => {
  for await (const num of asyncCounter()) {
    console.log(num); // 1, 2, 3 (delayed)
  }
})();
```

Key points:

- `async function*` defines an **async generator**.
    
- Each `yield` can await asynchronous operations.
    
- Consumed using `for await...of` loop.
    

Async iterators are powerful for **streaming data**, **reading files**, or **handling paginated APIs** where data arrives over time.