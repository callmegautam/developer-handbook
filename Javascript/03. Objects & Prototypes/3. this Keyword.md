### How `this` Works

`this` refers to the **execution context** — the object that the current code is being executed on.  
Its value depends on **how** a function is called, not where it’s defined.

---

### 1. Global Context

In the global scope:

- In a **browser**, `this` points to the `window` object.
    
- In **Node.js**, it points to `global` (but `undefined` in ES modules or strict mode).
    

```js
console.log(this); // window (browser)
```

In **strict mode**, `this` in the global context is `undefined`:

```js
"use strict";
console.log(this); // undefined
```

---

### 2. Inside a Regular Function

The value of `this` depends on **how** the function is called.

```js
function show() {
  console.log(this);
}
show(); // window (non-strict) or undefined (strict)
```

When called as a **method**, `this` refers to the **object before the dot**:

```js
const user = {
  name: "Gautam",
  greet() {
    console.log(this.name);
  }
};
user.greet(); // "Gautam"
```

If a function reference is detached, `this` defaults to global/undefined:

```js
const greet = user.greet;
greet(); // undefined (lost context)
```

---

### 3. Arrow Functions and Lexical `this`

Arrow functions **don’t have their own `this`** — they use `this` from their **lexical (outer) scope**.

```js
const obj = {
  name: "Gautam",
  arrow: () => console.log(this.name),
  regular() { console.log(this.name); }
};

obj.arrow();   // undefined (this = global)
obj.regular(); // "Gautam"
```

Useful for callbacks where you want to preserve outer `this`:

```js
function Timer() {
  this.seconds = 0;
  setInterval(() => this.seconds++, 1000); // arrow keeps `this`
}
const t = new Timer();
```

---

### 4. In Classes

Inside a class, `this` refers to the **instance** created by `new`.

```js
class User {
  constructor(name) {
    this.name = name;
  }
  greet() {
    console.log(`Hi, ${this.name}`);
  }
}
const u = new User("Gautam");
u.greet(); // "Hi, Gautam"
```

But if you pass a method as a callback, you lose context:

```js
setTimeout(u.greet, 1000); // undefined
```

Fix it with `.bind()`:

```js
setTimeout(u.greet.bind(u), 1000);
```

---

### 5. In Event Handlers

In browser event handlers:

- `this` refers to the **DOM element** that received the event.
    
- Arrow functions capture `this` from the outer lexical scope (not the element).
    

```js
document.querySelector("button").addEventListener("click", function() {
  console.log(this); // button element
});

document.querySelector("button").addEventListener("click", () => {
  console.log(this); // window or undefined (lexical `this`)
});
```

---

### `call`, `apply`, and `bind`

Used to **manually control** what `this` refers to when calling a function.

#### `call(thisArg, arg1, arg2, ...)`

Calls the function immediately with a specific `this` and arguments.

```js
function greet(greetWord) {
  console.log(`${greetWord}, ${this.name}`);
}
const user = { name: "Gautam" };
greet.call(user, "Hi"); // Hi, Gautam
```

#### `apply(thisArg, [argsArray])`

Same as `call()`, but arguments are passed as an array.

```js
greet.apply(user, ["Hello"]); // Hello, Gautam
```

#### `bind(thisArg, arg1, arg2, ...)`

Returns a **new function** with permanently bound `this`.  
It does **not** execute immediately.

```js
const boundGreet = greet.bind(user, "Hey");
boundGreet(); // Hey, Gautam
```

`bind()` is often used when passing methods as callbacks (to preserve `this` context).