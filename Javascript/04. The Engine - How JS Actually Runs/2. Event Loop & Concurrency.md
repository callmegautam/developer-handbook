### Single-Threaded Nature of JS

JavaScript runs on a **single thread**, meaning it executes one command at a time.  
However, through **asynchronous APIs** (like timers, promises, and I/O), JS can handle multiple operations _without blocking_.  
The event loop manages this illusion of concurrency by coordinating when queued tasks run after the main script finishes.

---

### Event Loop Phases

The **event loop** continuously checks whether the call stack is empty, and if so, it picks tasks from queues to execute.  
Each cycle of this process is called a **tick**.

Main components in a tick:

1. **Call Stack:** Where synchronous code executes.
    
2. **Task (Macrotask) Queue:** For async callbacks like `setTimeout`, I/O, or events.
    
3. **Microtask Queue:** For Promises and `process.nextTick` (Node.js).
    

Order of operations:

1. Execute all synchronous code.
    
2. Process all **microtasks**.
    
3. Execute one **macrotask** (e.g. a timer callback).
    
4. Repeat.
    

---

### Task Queue (Macrotasks) and Microtask Queue

**Macrotasks (Task Queue):**

- Include: `setTimeout`, `setInterval`, `setImmediate`, I/O events, UI rendering.
    
- Executed after the current stack and all microtasks are cleared.
    

**Microtasks (Microtask Queue):**

- Include: Promises (`.then`, `.catch`), `process.nextTick`, `queueMicrotask`.
    
- Run **immediately after** the current execution context but **before** the next macrotask.
    

```js
console.log("start");
setTimeout(() => console.log("timeout"), 0);
Promise.resolve().then(() => console.log("promise"));
console.log("end");

// Output: start → end → promise → timeout
```

---

### `setTimeout`, `setImmediate`, `process.nextTick`

#### `setTimeout`

Schedules a callback after a given delay (minimum time, not guaranteed exact delay).

```js
setTimeout(() => console.log("timeout"), 0);
```

#### `setImmediate` (Node.js)

Runs a callback **after** the current event loop iteration, _before_ any timers scheduled for the next tick.

```js
setImmediate(() => console.log("immediate"));
```

#### `process.nextTick` (Node.js)

Places a callback in the **microtask queue**, ensuring it runs **before** any I/O or timer callbacks.

```js
process.nextTick(() => console.log("nextTick"));
```

Execution order in Node.js:  
`process.nextTick` → microtasks → `setImmediate` / timers.

---

### Browser vs Node.js Event Loops

**Browser:**

- Manages tasks using Web APIs (`setTimeout`, `fetch`, DOM events).
    
- Event loop picks from the microtask queue after each macrotask.
    

**Node.js:**

- Has multiple event loop phases:
    
    1. **Timers**
        
    2. **Pending callbacks**
        
    3. **Idle/prepare**
        
    4. **Poll** (I/O events)
        
    5. **Check** (`setImmediate`)
        
    6. **Close callbacks**
        
- Between each phase, Node empties the microtask queue.
    

---

### Concurrency vs Parallelism

- **Concurrency:** Handling multiple tasks _overlapping in time_, even though only one executes at a moment. (JS model)
    
- **Parallelism:** Multiple tasks execute _simultaneously_ across different threads or CPUs. (e.g., Web Workers)
    

JavaScript achieves concurrency through **non-blocking I/O** and the event loop rather than actual parallel execution.

---

### Starvation and Performance Considerations

**Starvation:**  
Occurs when one type of queue (usually microtasks) keeps filling up, preventing other tasks from executing.

```js
function loop() {
  Promise.resolve().then(loop);
}
loop(); // Microtask starvation — event loop never returns to macrotasks
```

**Performance Tips:**

- Avoid blocking the event loop with long synchronous tasks.
    
- Break heavy computations using `setTimeout` or `queueMicrotask` to let the loop breathe.
    
- Use **Web Workers** or **Worker Threads** for CPU-intensive tasks.