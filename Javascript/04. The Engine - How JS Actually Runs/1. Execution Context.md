### Creation & Execution Phases

When any JavaScript code runs, it does so inside an **execution context** — the environment that stores variables, functions, and determines the value of `this`.  
There are **two phases** for every execution context:

#### 1. Creation Phase

- The engine sets up memory for variables and functions.
    
- Variables declared with `var` are **hoisted** and initialized as `undefined`.
    
- Functions are hoisted with their **entire definitions**.
    
- `let` and `const` are hoisted too but remain **uninitialized** (Temporal Dead Zone).
    
- A `this` binding is created.
    
- References to outer (parent) environments are set up.
    

#### 2. Execution Phase

- The code is executed line by line.
    
- Variables are assigned real values.
    
- Function calls create new **execution contexts** (pushed onto the call stack).
    

```js
let a = 10;
function sum(b) {
  return a + b;
}
sum(5); // New execution context for `sum`
```

When `sum()` runs, a **new execution context** is created specifically for it, while maintaining access to `a` from the outer scope via the **lexical environment**.

---

### Call Stack

The **call stack** is a data structure that keeps track of execution contexts.  
It operates on a **LIFO** (Last In, First Out) principle.

1. Global Execution Context (GEC) is created and pushed first.
    
2. Every function call creates a **new execution context**, which is pushed on top.
    
3. When the function finishes, its context is popped off the stack.
    

```js
function a() {
  b();
  console.log("a done");
}
function b() {
  console.log("b done");
}
a();
```

**Call Stack Order:**

```
Global → a() → b()
```

After `b()` finishes, its context is removed; control returns to `a()`.

---

### Memory Management (Stack vs Heap)

#### Stack

Used for **primitive values** and **execution contexts**.  
Values are stored directly and have fixed size.

```js
let x = 42;
let y = x; // copied by value
```

Both variables hold independent copies.

#### Heap

Used for **non-primitive values (objects, arrays, functions)**.  
Objects are stored by **reference**, and variables hold pointers to these memory locations.

```js
let obj1 = { a: 1 };
let obj2 = obj1; // both reference the same memory
obj2.a = 99;
console.log(obj1.a); // 99
```

Garbage collection frees unused objects in the heap automatically.

---

### Variable Environment vs Lexical Environment

#### Variable Environment

- Contains variable/function declarations **within the current execution context**.
    
- Includes `var`, `let`, `const`, and function names.
    

#### Lexical Environment

- Includes the **current variable environment** and a **reference to its outer environment** (from where the function was defined, not where it’s called).
    

```js
function outer() {
  let a = 10;
  function inner() {
    let b = 5;
    console.log(a + b);
  }
  inner();
}
outer();
```

Here:

- `inner()`’s **lexical environment** contains its own `b` and a reference to `outer()`’s environment where `a` exists.
    
- This link forms the **scope chain**, allowing access to variables in parent scopes.
    

---

In summary:

- The **execution context** provides the runtime environment for code.
    
- The **call stack** manages function execution order.
    
- **Stack vs Heap** determines where and how data is stored.
    
- The **lexical environment** enables scope and closures by linking inner and outer contexts.