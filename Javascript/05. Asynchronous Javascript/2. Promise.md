### Creating and Consuming Promises

A **Promise** is an object representing the eventual completion or failure of an asynchronous operation.  
It has three states:

- **Pending:** Initial state
    
- **Fulfilled:** Operation succeeded (`resolve`)
    
- **Rejected:** Operation failed (`reject`)
    

```js
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    const success = true;
    if (success) resolve("Data received");
    else reject("Error occurred");
  }, 1000);
});

promise
  .then((data) => console.log(data))
  .catch((err) => console.error(err));
```

---

### `then`, `catch`, `finally`

- **`then()`** → runs on success (fulfillment)
    
- **`catch()`** → runs on failure (rejection)
    
- **`finally()`** → always runs, regardless of outcome (for cleanup)
    

```js
promise
  .then((data) => console.log("Success:", data))
  .catch((err) => console.error("Failed:", err))
  .finally(() => console.log("Done"));
```

`finally()` doesn’t receive any argument; it’s just for cleanup or logging.

---

### Promise Chaining

You can return another promise inside `.then()` to create a **chain** of async operations.  
Each `.then()` waits for the previous one to complete.

```js
getUser()
  .then((user) => getPosts(user.id))
  .then((posts) => getComments(posts[0].id))
  .then((comments) => console.log(comments))
  .catch((err) => console.error(err));
```

Each `.then()` returns a **new promise**, which enables chaining.

---

### Error Handling in Promise Chains

If any promise in the chain rejects, control jumps to the nearest `.catch()`.

```js
Promise.resolve(10)
  .then((num) => {
    throw new Error("Oops");
  })
  .then(() => console.log("Never runs"))
  .catch((err) => console.error("Caught:", err.message))
  .finally(() => console.log("Cleanup"));
```

A `.catch()` can also recover the chain by returning a resolved value.

```js
Promise.reject("error")
  .catch(() => "default value")
  .then((val) => console.log(val)); // "default value"
```

---

### `Promise.all`, `Promise.allSettled`, `Promise.race`, `Promise.any`

#### `Promise.all(iterable)`

Runs multiple promises in parallel.  
Resolves when **all** promises fulfill, rejects if **any** fail.

```js
Promise.all([
  fetch("/user"),
  fetch("/posts"),
])
  .then((results) => console.log("All done"))
  .catch((err) => console.error("One failed", err));
```

If one rejects, the rest are ignored.

---

#### `Promise.allSettled(iterable)`

Waits for all promises to complete (fulfilled or rejected) and returns an array of results.

```js
Promise.allSettled([
  Promise.resolve("OK"),
  Promise.reject("Error"),
]).then(console.log);
```

Output:

```js
[
  { status: "fulfilled", value: "OK" },
  { status: "rejected", reason: "Error" }
]
```

---

#### `Promise.race(iterable)`

Resolves or rejects **as soon as the first promise settles** (whichever finishes first).

```js
Promise.race([
  fetch("/slow"),
  fetch("/fast"),
]).then(console.log);
```

---

#### `Promise.any(iterable)`

Resolves with the **first fulfilled** promise, ignoring rejections.  
If all reject, it throws an `AggregateError`.

```js
Promise.any([
  Promise.reject("fail"),
  Promise.resolve("success"),
]).then(console.log); // "success"
```

---

Promises are the foundation of modern asynchronous JS — they simplify async flow control, handle errors predictably, and serve as the base for `async/await`.