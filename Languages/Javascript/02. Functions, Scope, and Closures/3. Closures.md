### What Are Closures?

A **closure** is created when an inner function **remembers variables** from its **outer function’s scope**, even after the outer function has finished executing.

In simple terms — a function bundled with its lexical environment.

```js
function outer() {
  let count = 0;
  function inner() {
    count++;
    console.log(count);
  }
  return inner;
}

const counter = outer();
counter(); // 1
counter(); // 2 (still remembers count)
```

`counter` keeps access to `count` even though `outer()` has already returned — that’s the closure at work.

---

### Use Cases

#### 1. Encapsulation (Private Variables)

Closures allow **data privacy** — variables stay hidden inside the function scope.

```js
function createCounter() {
  let value = 0;
  return {
    increment() { value++; },
    get() { return value; }
  };
}

const counter = createCounter();
counter.increment();
console.log(counter.get()); // 1
```

`value` is not directly accessible outside — it’s effectively “private.”

#### 2. Function Factories

Closures let you create **configurable functions**.

```js
function multiplyBy(n) {
  return function(x) {
    return x * n;
  };
}

const double = multiplyBy(2);
const triple = multiplyBy(3);

console.log(double(5)); // 10
console.log(triple(5)); // 15
```

Each returned function “remembers” its own `n`.

#### 3. Maintaining State in Async Code

Closures keep state between asynchronous calls.

```js
function delayedLogger(msg) {
  setTimeout(() => console.log(msg), 1000);
}
delayedLogger("Hello Closure!");
```

The callback retains access to `msg`, even though `delayedLogger` has finished executing.

---

### Common Closure Pitfalls

#### 1. Closures in Loops

All inner functions in a loop share the same reference to a variable, causing unexpected behavior.

```js
for (var i = 1; i <= 3; i++) {
  setTimeout(() => console.log(i), 1000);
}
// Output: 4, 4, 4
```

To fix:

- Use `let` (block scope creates a new binding each iteration).
    
- Or wrap in an IIFE (Immediately Invoked Function Expression).
    

```js
for (let i = 1; i <= 3; i++) {
  setTimeout(() => console.log(i), 1000); // 1, 2, 3
}
```

#### 2. Memory Leaks

If closures unintentionally capture large data or DOM references, they can prevent garbage collection. Always clean up unused references.

---

### Real-World Patterns Using Closures

#### 1. Event Handlers

```js
function setupButton(id) {
  let count = 0;
  document.getElementById(id).addEventListener("click", () => {
    count++;
    console.log(`Clicked ${count} times`);
  });
}
setupButton("btn");
```

Each button keeps its own `count`.

#### 2. Debouncing / Throttling

Used to control the rate of function execution in performance-sensitive code.

```js
function debounce(fn, delay) {
  let timer;
  return function(...args) {
    clearTimeout(timer);
    timer = setTimeout(() => fn.apply(this, args), delay);
  };
}
```

`timer` is preserved across calls via closure.

#### 3. Module Pattern

Used to simulate private data and expose only public methods.

```js
const CounterModule = (function() {
  let count = 0;
  function increment() { count++; }
  function getCount() { return count; }
  return { increment, getCount };
})();

CounterModule.increment();
console.log(CounterModule.getCount()); // 1
```

Closures keep `count` private while exposing a clean public API.