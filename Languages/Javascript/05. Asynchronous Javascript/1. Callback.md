### Callback Functions and Callback Hell

A **callback** is a function passed as an argument to another function to be executed later, usually after an asynchronous operation completes.

```js
function fetchData(callback) {
  setTimeout(() => {
    callback("data received");
  }, 1000);
}

fetchData((msg) => console.log(msg)); // data received
```

Callbacks allow asynchronous behavior without blocking the main thread, but nesting them deeply leads to **callback hell** — a pyramid-like structure that’s hard to read, debug, and maintain.

```js
getUser((user) => {
  getPosts(user.id, (posts) => {
    getComments(posts[0].id, (comments) => {
      console.log(comments);
    });
  });
});
```

This nesting problem makes error handling and flow control complex.

---

### Error-First Callbacks

A standard Node.js convention where the **first argument** in a callback is reserved for an **error object**, and the second for **data**.

```js
function readFile(callback) {
  setTimeout(() => {
    const error = false;
    if (error) callback("File not found", null);
    else callback(null, "File content");
  }, 500);
}

readFile((err, data) => {
  if (err) console.error(err);
  else console.log(data);
});
```

This ensures consistent error handling across asynchronous APIs — you always check for `err` before using the result.

---

### Async Flow Issues

Callbacks introduce several control-flow challenges:

1. **Inversion of Control:**  
    You hand control of your function to another piece of code, which might call it incorrectly or multiple times.
    
2. **Error Propagation:**  
    Errors inside callbacks can’t be caught using `try...catch` in outer scopes because they execute asynchronously.
    
    ```js
    try {
      setTimeout(() => { throw new Error("fail"); }, 100);
    } catch (e) {
      console.log("never reached");
    }
    ```
    
3. **Callback Hell:**  
    Multiple dependent asynchronous steps lead to deeply nested code that’s hard to reason about.
    

These limitations led to the introduction of **Promises** and later **async/await**, which solve these flow and readability issues.