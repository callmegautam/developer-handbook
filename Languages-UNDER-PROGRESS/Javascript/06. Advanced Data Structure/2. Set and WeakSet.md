## 2. Sets and WeakSets

### Uniqueness Property

A **Set** is a collection of unique values — duplicates are automatically removed.  
Order is preserved (insertion order), but there are no indexes.

```js
const set = new Set([1, 2, 2, 3]);
console.log(set); // Set(3) {1, 2, 3}

set.add(4);
set.has(2); // true
set.delete(3);
```

Useful methods:

- `.add(value)` – adds a new value
    
- `.delete(value)` – removes a value
    
- `.has(value)` – checks existence
    
- `.clear()` – removes all elements
    
- `.size` – returns number of elements
    

Sets work with any value type, including objects (by reference).

```js
const obj = {};
const s = new Set();
s.add(obj);
console.log(s.has({})); // false (different reference)
```

You can convert between sets and arrays easily:

```js
const arr = [1, 2, 2, 3];
const unique = [...new Set(arr)]; // [1, 2, 3]
```

---

### Use Cases for Caching and Deduplication

1. **Remove duplicates from arrays**
    
    ```js
    const nums = [1, 1, 2, 3, 3];
    const unique = [...new Set(nums)];
    ```
    
2. **Track unique items**
    
    ```js
    const visited = new Set();
    visited.add("home");
    visited.add("about");
    console.log(visited.has("home")); // true
    ```
    
3. **Caching results**
    
    ```js
    const cache = new Set();
    function fetchOnce(id) {
      if (cache.has(id)) return "Cached result";
      cache.add(id);
      return "Fetched fresh";
    }
    ```
    
4. **Intersection, Union, and Difference**
    
    ```js
    const a = new Set([1, 2, 3]);
    const b = new Set([3, 4, 5]);
    
    const union = new Set([...a, ...b]); // {1, 2, 3, 4, 5}
    const intersection = new Set([...a].filter(x => b.has(x))); // {3}
    const difference = new Set([...a].filter(x => !b.has(x))); // {1, 2}
    ```
    

---

### WeakSet Memory Behavior

A **WeakSet** is similar to a Set, but it only stores **object references**, not primitives, and does **not prevent garbage collection** of those objects.

```js
const weak = new WeakSet();
let user = { name: "Gautam" };
weak.add(user);

console.log(weak.has(user)); // true
user = null; // object becomes unreachable → garbage collected
```

Key characteristics:

- Only accepts **objects** (no numbers, strings, etc.)
    
- **Weak references** – if the object is no longer referenced elsewhere, it’s removed automatically.
    
- Not iterable — you can’t loop over it or get its size.
    

```js
const ws = new WeakSet();
const obj = {};
ws.add(obj);
console.log(ws.has(obj)); // true
// No ws.size or ws.forEach()
```

**Use case:**  
Track object states or cache references **without preventing memory cleanup**, e.g., storing DOM nodes or temporary data that should auto-expire.