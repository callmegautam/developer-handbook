
### Function Declaration vs Expression

**Function Declaration:**  
Defined with the `function` keyword and **hoisted**, meaning they can be called before their definition.

```js
greet(); // works
function greet() {
  console.log("Hello");
}
```

**Function Expression:**  
Assigned to a variable. **Not hoisted** — can only be used after definition.

```js
const greet = function() {
  console.log("Hi");
};
greet(); // works only after definition
```

Function expressions are often used for callbacks, closures, and IIFEs (Immediately Invoked Function Expressions).

---

### Arrow Functions and Lexical `this`

Arrow functions provide a shorter syntax and **do not have their own `this`** — they capture `this` from their enclosing scope (lexical `this`).

```js
const user = {
  name: "Gautam",
  regularFn: function() {
    console.log(this.name); // "Gautam"
  },
  arrowFn: () => {
    console.log(this.name); // undefined (this = global)
  }
};
user.regularFn();
user.arrowFn();
```

They are **not suitable** for object methods or constructors.

```js
const add = (a, b) => a + b;
```

---

### Default Parameters

Allow parameters to have default values if not provided or explicitly `undefined`.

```js
function multiply(a, b = 2) {
  return a * b;
}
multiply(5); // 10
multiply(5, 3); // 15
```

Defaults can also depend on earlier parameters.

```js
function greet(name, msg = `Hello ${name}`) {
  console.log(msg);
}
greet("Gautam"); // Hello Gautam
```

---

### Higher-Order Functions

Functions that **take other functions as arguments** or **return a function**.  
They form the foundation of functional programming in JavaScript.

```js
function repeat(fn, times) {
  for (let i = 0; i < times; i++) fn();
}

repeat(() => console.log("Hi"), 3);
```

Common higher-order functions in JS: `map`, `filter`, `reduce`, `forEach`.

```js
[1, 2, 3].map(x => x * 2); // [2, 4, 6]
```

---

### Function Overloading (Conceptual)

JavaScript does **not support true function overloading** (like Java or C++), but you can simulate it by checking argument types or counts.

```js
function greet(name, age) {
  if (arguments.length === 1) console.log("Hello " + name);
  else console.log(`Hello ${name}, age ${age}`);
}

greet("Gautam"); // Hello Gautam
greet("Gautam", 21); // Hello Gautam, age 21
```

---

### Pure vs Impure Functions

**Pure Functions**

- Always return the same output for the same input.
    
- Do not modify external state (no side effects).
    

```js
function add(a, b) {
  return a + b; // pure
}
```

**Impure Functions**

- Depend on or modify external variables/state.
    
- Have side effects like logging, network calls, or DOM updates.
    

```js
let total = 0;
function addToTotal(n) {
  total += n; // impure
}
```

Pure functions are **predictable and testable**, while impure ones handle **real-world interactions** (I/O, DOM, APIs).