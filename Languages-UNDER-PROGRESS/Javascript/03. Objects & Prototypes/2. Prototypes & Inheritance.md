### Prototype Chain

Every JavaScript object has an internal link to another object called its **prototype**.  
If a property or method isn’t found on the object itself, JavaScript looks for it **up the prototype chain** until it reaches `Object.prototype`.

```js
const user = { name: "Gautam" };
console.log(user.toString()); // found in Object.prototype
```

If the property doesn’t exist anywhere in the chain, `undefined` is returned.

Prototype chain order:  
`user → Object.prototype → null`

---

### `__proto__` vs `prototype`

#### `__proto__`

- Property on **instances** that references their internal prototype.
    
- Used for prototype lookup (read-only link in modern JS).
    

```js
const obj = {};
console.log(obj.__proto__ === Object.prototype); // true
```

#### `prototype`

- Property on **constructor functions** that defines what should be linked to created objects.
    
- Used only with functions that act as constructors.
    

```js
function User(name) {
  this.name = name;
}
User.prototype.greet = function() {
  console.log(`Hi, ${this.name}`);
};

const u1 = new User("Gautam");
u1.greet(); // "Hi, Gautam"
console.log(u1.__proto__ === User.prototype); // true
```

---

### Constructor Functions

Before ES6 `class`, constructor functions were used to create reusable object blueprints.

```js
function Person(name, age) {
  this.name = name;
  this.age = age;
}
Person.prototype.sayHi = function() {
  console.log(`Hello, ${this.name}`);
};

const p1 = new Person("Gautam", 21);
p1.sayHi(); // Hello, Gautam
```

`new` keyword creates a new object, sets its prototype to `Person.prototype`, and binds `this` inside the constructor.

---

### Classical vs Prototypal Inheritance

#### Classical Inheritance

Like Java or C++ — classes define blueprints, and instances are copies.  
ES6 `class` syntax mimics this style.

#### Prototypal Inheritance

Objects inherit directly from other objects (no class duplication).  
More flexible and dynamic.

```js
const human = { kind: "Human" };
const person = Object.create(human);
person.name = "Gautam";
console.log(person.kind); // "Human"
```

Changes to `human` reflect in all objects created from it (unless overridden).

---

### `Object.create`

Creates a new object with a specified prototype.

```js
const animal = { eats: true };
const dog = Object.create(animal);
dog.barks = true;

console.log(dog.eats); // true (inherited)
console.log(Object.getPrototypeOf(dog) === animal); // true
```

Useful for creating custom inheritance chains or pure prototype-based design.

---

### ES6 `class`, `extends`, `super`

Syntactic sugar over the prototype system.

```js
class Person {
  constructor(name) {
    this.name = name;
  }
  greet() {
    console.log(`Hello, ${this.name}`);
  }
}

class Student extends Person {
  constructor(name, grade) {
    super(name); // calls parent constructor
    this.grade = grade;
  }
  study() {
    console.log(`${this.name} is studying`);
  }
}

const s1 = new Student("Gautam", "A");
s1.greet(); // Hello, Gautam
s1.study(); // Gautam is studying
```

- `extends` → establishes prototype inheritance between classes.
    
- `super()` → calls the parent constructor or parent method.
    

Under the hood, it’s still prototype chaining — `Student.prototype` inherits from `Person.prototype`.

---

### Static Properties & Methods

Static members belong to the **class itself**, not to instances.

```js
class MathUtils {
  static add(a, b) {
    return a + b;
  }
}
console.log(MathUtils.add(2, 3)); // 5

const m = new MathUtils();
console.log(typeof m.add); // undefined (not available on instance)
```

Static methods are used for **utility or factory functions** that don’t depend on instance data.