### Object Literals and Constructors

Objects store key–value pairs and are the foundation of JavaScript data structures.

#### Object Literals

Easiest way to create an object.

```js
const user = {
  name: "Gautam",
  age: 21,
  greet() {
    console.log(`Hi, I'm ${this.name}`);
  }
};
user.greet(); // Hi, I'm Gautam
```

#### Constructor Function

Used to create multiple similar objects.

```js
function User(name, age) {
  this.name = name;
  this.age = age;
}
const u1 = new User("Gautam", 21);
```

#### `Object` Constructor

```js
const obj = new Object({ x: 1 });
```

---

### Property Descriptors and `Object.defineProperty`

Each object property has **descriptors** controlling its behavior:

- `value` → actual data
    
- `writable` → can be changed
    
- `enumerable` → shows up in loops
    
- `configurable` → can be deleted or modified
    

```js
const user = {};
Object.defineProperty(user, "name", {
  value: "Gautam",
  writable: false,
  enumerable: true,
  configurable: false
});
console.log(user.name); // Gautam
user.name = "JS"; // ignored (non-writable)
```

To inspect property settings:

```js
console.log(Object.getOwnPropertyDescriptor(user, "name"));
```

---

### Enumeration (`for...in`, `Object.keys`, `Object.entries`)

#### `for...in`

Iterates over **enumerable keys** (including inherited ones).

```js
for (let key in user) {
  console.log(key);
}
```

#### `Object.keys()`

Returns an array of own enumerable property names.

```js
Object.keys(user); // ['name']
```

#### `Object.entries()`

Returns key–value pairs as an array.

```js
Object.entries(user); // [['name', 'Gautam']]
```

#### `Object.values()`

Returns only values.

```js
Object.values(user); // ['Gautam']
```

---

### Cloning vs Reference

Objects are **reference types**, so assignment copies the reference, not the value.

```js
const obj1 = { a: 1 };
const obj2 = obj1;
obj2.a = 99;
console.log(obj1.a); // 99 (same reference)
```

To avoid shared references, clone instead.

---

### Shallow vs Deep Copy

#### Shallow Copy

Copies only top-level properties. Nested objects remain references.

```js
const original = { a: 1, b: { c: 2 } };
const shallow = { ...original };
shallow.b.c = 99;
console.log(original.b.c); // 99 (linked)
```

#### Deep Copy

Creates a full, independent clone (no shared references).

```js
const deep = JSON.parse(JSON.stringify(original));
deep.b.c = 10;
console.log(original.b.c); // 99 (unaffected)
```

However, this method loses functions, `undefined`, and special types.

---

### `Object.assign`, Spread Syntax, `structuredClone`

#### `Object.assign()`

Copies properties from source to target.

```js
const target = { a: 1 };
const source = { b: 2 };
Object.assign(target, source);
// { a: 1, b: 2 }
```

Performs a **shallow copy**.

#### Spread Syntax (`...`)

More modern and concise alternative.

```js
const obj = { ...target, ...source };
```

Also shallow.

#### `structuredClone()`

Creates a **deep clone** preserving nested data and special types like `Date`, `Map`, `Set`.

```js
const original = { a: 1, b: { c: 2 } };
const copy = structuredClone(original);
copy.b.c = 99;
console.log(original.b.c); // 2
```

`structuredClone` is available in modern browsers and Node.js 17+.